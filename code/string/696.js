/**
 * 696. 计数二进制子串
  给定一个字符串s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
  重复出现的子串要计算它们出现的次数。

  示例 1 :
  输入: "00110011"
  输出: 6
  解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

  请注意，一些重复出现的子串要计算它们出现的次数。

  另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。

  示例 2 :
  输入: "10101"
  输出: 4
  解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

  注意：
  s.length在1到50,000之间。
  s只包含“0”或“1”字符。
 */

// 方法一 从头开始找子串
// 00110011 从第一位开始依次往后找到第一个子串
// 00110011 -> 0011
// 0110011 -> 01
// 110011 -> 1100
// 10011 -> 10
// ... 以此类推
// export default (str) => {
//   // 建立数据结构， 堆栈，保存数据
//   let r = []
//   // 给定任意子输入都返回符合条件的第一个子串
//   let match = (str) => {
//     // 找到从字符串第一位开始连续的0或者1
//     let j = str.match(/^(0+|1+)/)[0]
//     // 与j长度相同但取反的字符串
//     let o = (j[0] ^ 1).toString().repeat(j.length)
//     let reg = new RegExp(`^(${j}${o})`)
//     if (reg.test(str)) {
//       return RegExp.$1
//     } else {
//       return ''
//     }
//   }
//   // 通过for循环控制程序运行的流程
//   for (let i = 0, len = str.length - 1; i < len; i++) {
//     let sub = match(str.slice(i))
//     if (sub) {
//       r.push(sub)
//     }
//   }
//   return r
// }

// 方法二 字符串分组 先分组后计算
// export default (str) => {
//   // 保存子串个数
//   let n = 0
//   // 将字符串按连续的0或1分组
//   // 如 00101 -> ['00', '1', '0', '1']
//   // 101011 -> ['1', '0', '1', '0', '11']
//   // 可以看出数组相邻两项之间可以组成的子串个数等于长度最小的那一项的长度
//   // 如 '00','1' 有一个子串 '01'  '1','0' 有一个子串 '10'
//   let arr = str.match(/([1]+)|([0]+)/g)
//   // 通过for循环计算总的子串个数
//   for (let i = 0, len = arr.length - 1; i < len; i++) {
//     n += Math.min(arr[i].length, arr[i + 1].length)
//   }
//   return n
// }

// 方法三 线性扫描 一遍扫描，边检查边计算 不需要进行一次分组，会比上面的方法空间复杂度更小
export default (str) => {
  // n 保存子串个数
  // cur prev 当前连续字符串和前一个连续字符串的长度
  // 例如 1001101 从左到右进行扫描依次得到的是
  // cur[1] = 1, prev[] = 0
  // cur[0] = 1, prev[1] = 1, n++
  // cur[00] = 2, prev[1] = 1
  // cur[1] = 1, prev[00] = 2, n++
  // cur[11] = 2, prev[00] = 2, n++
  // cur[0] = 1, prev[11] = 2, n++
  // cur[1] = 1, prev[0] = 1, n++
  // 最后 n = 5
  let n = 0
  let prev = 0
  let cur = 1
  // 通过for循环计算总的子串个数
  for (let i = 0, len = str.length - 1; i < len; i++) {
    if (str[i] === str[i + 1]) {
      cur++
    } else {
      prev = cur
      cur = 1
    }
    // 前一个连续字符串的长度大于等于当前连续字符串的长度时，则可以形成一个子串
    // 如 001 -> 01  0011 -> 0011
    // 011 在 01 的时候已经统计过一次，所以不需要再统计
    if (prev >= cur) n++
  }
  return n
}
